---
title: Code First Migrations в командных средах - EF6
author: divega
ms.date: 10/23/2016
ms.assetid: 4c2d9a95-de6f-4e97-9738-c1f8043eff69
ms.openlocfilehash: 53460b6cdd454099ccf93b4e2133e4ea21278a64
ms.sourcegitcommit: fa863883f1193d2118c2f9cee90808baa5e3e73e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/04/2018
ms.locfileid: "52857472"
---
# <a name="code-first-migrations-in-team-environments"></a>Code First Migrations в командных средах
> [!NOTE]
> В этой статье предполагается, что вы знаете, как использовать Code First Migrations в основных сценариях. Если этого не сделать, то нужно будет прочесть [Code First Migrations](~/ef6/modeling/code-first/migrations/index.md) перед продолжением.

## <a name="grab-a-coffee-you-need-to-read-this-whole-article"></a>Перерыв на кофе, необходимо прочитать эту статью

Данные о проблемах в командных средах являются главным образом вокруг слияние миграций, когда два разработчика создали миграций, в свою базу кода на локальном. Хотя необходимые действия для решения этих довольно просты, они требуют понимаете принцип работы миграций. Пожалуйста не просто сразу перейти к концу — уделить время читать эту статью, чтобы убедиться, что вы все.

## <a name="some-general-guidelines"></a>Некоторые общие рекомендации

Прежде чем мы углубимся в управлении слияния миграции, созданных несколькими разработчиками, ниже приведены некоторые общие рекомендации, чтобы установить для успешного.

### <a name="each-team-member-should-have-a-local-development-database"></a>Каждый член команды должен иметь локальной разработки базы данных

Использует миграций  **\_ \_MigrationsHistory** таблицу для хранения, какие виды миграции были применены к базе данных. При наличии нескольких разработчиков, создание миграцию по отдельности при попытке предназначенных для той же базе данных (и тем самым совместно использовать  **\_ \_MigrationsHistory** таблицы) миграции будет крайне запутанным.

Само собой при наличии участников команды, которые не создаются миграций, не возникало необходимости их совместное использование базы данных центра разработки.

### <a name="avoid-automatic-migrations"></a>Избегайте автоматический перенос

Суть в том, что автоматический перенос изначально красиво в командных средах, но на самом деле они просто не работают. Если вы хотите узнать почему, читайте дальше, — в противном случае перейдите к следующему разделу.

Автоматический перенос позволяет иметь схему базы данных, обновляется в соответствии с текущей моделью без необходимости создания файлов кода (миграция на базе кода). Автоматический перенос будет очень хорошо работать в среде группы, если вы только использовали их и никогда не создаются все миграции на основе кода. Проблема заключается в том, что автоматический перенос ограничены и не обрабатывают несколько операций – свойство столбец переименование, перемещение данных в другую таблицу, и т.д. Для обработки таких ситуаций, вы в итоге создание миграции на основе кода (и редактирования шаблонный код), которые используются переменные типов между изменения, которые обрабатываются автоматический перенос. Это позволяет практически на невозможно выполнить слияние изменений, когда два разработчика проверять при миграции.

## <a name="screencasts"></a>Демонстрационные ролики

Если вместо этого будет смотреть презентация, чем, в этой статье, следующие два видео рассматриваются то же содержимое, что в этой статье.

### <a name="video-one-migrations---under-the-hood"></a>Один видео: «Миграции — взгляд изнутри»

[Этот демонстрационный ролик](http://channel9.msdn.com/blogs/ef/migrations-under-the-hood) рассматривается как отслеживает миграций и использует сведения о модели для обнаружения изменений в модели.

### <a name="video-two-migrations---team-environments"></a>Два видео: «Миграции — командные среды»

Основываясь на концепциях из предыдущих видео, [этой трансляции](http://channel9.msdn.com/blogs/ef/migrations-team-environments) рассматриваются проблемы, возникающие в среде team и способы их устранения.

## <a name="understanding-how-migrations-works"></a>Основные сведения о работе миграции

Ключ для успешного использования миграции в среде группы представляет собой простую, основные сведения о том, как миграция отслеживает и использует сведения о модели для обнаружения изменений в модели.

### <a name="the-first-migration"></a>Первой миграции

При добавлении первой миграции в проект, выполните примерно **Add-Migration первый** в консоли диспетчера пакетов. Описаны основные шаги, которые выполняет эту команду показанные на рисунке ниже.

![Первой миграции](~/ef6/media/firstmigration.png)

Текущая модель вычисляется на основе кода (1). Объекты базы данных, необходимых затем вычисляются в ходе различия модели (2) — так как это первой миграции модели различаются только использует пустой модели для сравнения. Необходимые изменения передаются в генератор кода для сборки кода требуется миграции (3), который затем добавляется в решение Visual Studio (4).

Помимо фактического переноса кода, который хранится в основной файл кода миграций также создает некоторые дополнительные файлы кода. Эти файлы метаданных, который используется с помощью миграций и не то, что следует изменять. Один из этих файлов является файлом ресурсов (.resx), с моментальным снимком модели во время миграции был создан. Вы увидите, как он используется на следующем шаге.

На этом этапе, скорее всего, нужно выполнить **Update-Database** Чтобы применить изменения к базе данных, а затем перейдите о реализации других частях приложения.

### <a name="subsequent-migrations"></a>Последующей миграции

Позже вы сможете вернуться и внести некоторые изменения в модель, — в нашем примере мы добавим **URL-адрес** свойства **блог**. Можно затем выдать команду например **AddUrl Add-Migration** сформировать шаблон миграции для применения соответствующей базы данных изменений. Описаны основные шаги, которые выполняет эту команду показанные на рисунке ниже.

![Второй миграции](~/ef6/media/secondmigration.png)

Так же, как в последний раз текущей модели вычисляется на основе кода (1). Тем не менее это время существует имеющихся миграций, Предыдущая модель извлекается из последней миграции (2). Эти две модели представляют собой diffed базы данных, необходимых изменений (3), а затем процесс завершает работу, как и раньше.

Этот же процесс используется для все дополнительные миграции, добавляемые в проект.

### <a name="why-bother-with-the-model-snapshot"></a>А зачем возиться с моментального снимка модели?

Может возникнуть вопрос, почему остановились EF с моментальным снимком модели — почему не только взгляд на базе данных. Если это так, читайте дальше. Если вы не хотите можно пропустить этот раздел.

Существует ряд причин, по которым EF сохраняет моментальный снимок модели решения.

-   Это позволяет базе данных для отклонения от модели EF. Эти изменения можно внести непосредственно в базе данных, или шаблонный код можно изменить в миграции для внесения изменений. Ниже приведены несколько примеров это на практике.
    -   Вы хотите добавить столбец, чтобы один или несколько таблиц Inserted и Updated, но вы не хотите включать эти столбцы в модели EF. Если оно постоянно попытается удалить эти столбцы, каждый раз, сформированного миграции базы данных миграции. С помощью моментального снимка модели, EF только когда-либо обнаружит законные возможности внесения изменений в модель.
    -   Вы хотите изменить текст хранимую процедуру, используемую для обновления для включения некоторых ведения журнала. Если миграций рассмотрели этой хранимой процедуры из базы данных она будет постоянно попробуйте и восстановить его определение, которое ожидает, что EF. С помощью моментального снимка модели, EF будет только сформировать код для изменения хранимой процедуры, при изменении вида процедуру, описанную в модель EF.
    -   Эти же принципы применимы к добавлению дополнительных индексов, включая дополнительные таблицы в базе данных, сопоставление EF представление базы данных, которая размещается на таблицы и т. д.
-   Модель EF содержит не только фигуры базы данных. Наличие всей модели позволяет миграций просмотреть сведения о свойствах и классы в модели и их сопоставлении столбцов и таблиц. Эта информация позволяет миграции на более разумно, в коде, который она формирует шаблоны. Например при изменении имени столбца, который сопоставляет свойство миграции может обнаруживать переименования, зная, что это то же свойство — то, что невозможно при наличии только схему базы данных. 

## <a name="what-causes-issues-in-team-environments"></a>Что вызывает проблемы в средах рабочих групп

Рабочий процесс рассматривается в предыдущем разделе отлично работает, когда вы работаете в одной в приложении. Он также хорошо работает в среде группы, если вы являетесь единственным лицом, внесение изменений в модели. В этом сценарии можно внесение изменений модели, создания миграции и их отправки в системе управления версиями. Другие разработчики могут синхронизировать изменения и запуска **Update-Database** для применения изменений схемы.

Проблемы начинают возникать при наличии нескольких разработчиков, внесение изменений в модель EF и отправки в систему управления версиями, в то же время. EF отсутствует способ первого класса для слияния локальной миграции с миграциями, другой разработчик отправил в систему управления версиями, с момента последней синхронизации.

## <a name="an-example-of-a-merge-conflict"></a>Пример конфликта слияния

Первый Рассмотрим конкретный пример такой конфликт слияния. Мы продолжим на примере, рассмотренном ранее. Давайте качестве отправной точки предполагается изменения в предыдущем разделе были возвращены исходном разработчиком. Мы будем отслеживать два разработчика, они внесения изменений в код базового.

Мы будем отслеживать модель EF и миграции через ряд изменений. Для начала разработчиков синхронизированы репозиторием системы управления версиями, как показано на следующем рисунке.

![Начальная точка](~/ef6/media/startingpoint.png)

Разработчик \#1 и developer \#2 теперь вносит изменения в модель EF в своем локальном коде базовый. Разработчик \#добавляет 1 **Оценка** свойства **блог** — и создает **AddRating** миграции, чтобы применить изменения к базе данных. Разработчик \#2 добавляет **читатели** свойства **блог** — и создает соответствующий **AddReaders** миграции. Запустите разработчиков **Update-Database**, чтобы применить изменения к их локальным базам данных, а затем продолжить разработку приложения.

> [!NOTE]
> Миграция начинаются с префикса метку времени, поэтому графика представляет, AddReaders миграции от разработчика \#2 переходит после миграции AddRating от разработчика \#1. Ли разработчик \#1 или \#2 созданный делает первой миграции не влияет на проблемы в работе в команде или процесс объединения, которые мы рассмотрим в следующем разделе.

![Локальные изменения](~/ef6/media/localchanges.png)

Это Счастливое день для разработчиков \#1 они происходят сначала отправить их изменения. Поскольку никто не проверен, поскольку они синхронизированы их репозитории, их просто предоставлять свои изменения без выполнения любой слияние.

![Отправить](~/ef6/media/submit.png)

Теперь настало время для разработчиков \#2 для отправки. Они не повезло. Так как кто-то другой отправил изменения, поскольку они синхронизированы, им необходимо будет извлечь изменения и слияния. Система управления версиями будет автоматически слияния изменений на уровне кода, поскольку они очень просты. Состояние разработчика \#2 в локальном репозитории после синхронизации показан на следующем рисунке. 

![По запросу](~/ef6/media/pull.png)

На этот этап разработчика \#2 можно запустить **обновления базы данных** обнаружит, что новый **AddRating** миграции (который не был применен для разработчика \#2 базы данных) и применить его. Теперь **Оценка** столбец будет добавлен **блоги** таблицы и базы данных в соответствии с моделью.

Однако существует несколько проблем:

1.  Несмотря на то что **Update-Database** применит **AddRating** миграции также приводит к формированию предупреждения: *не удалось обновить базу данных для соответствия текущей модели, так как имеются ожидающие изменения и отключается автоматическая миграция...*
    Проблема в том, что моментальный снимок модели хранятся в последней миграции (**AddReader**) отсутствует **Оценка** свойство **блог** (так как он не был частью модели при миграции был создан). Код сначала обнаруживает, что модель в последней миграции не совпадает с текущей моделью и выдает предупреждение.
2.  Запуск приложения приведет к появлению исключения InvalidOperationException о том, что "*модель, поддерживающая контекст «BloggingContext» изменилось с момента создания базы данных. Рассмотрите возможность использования Code First Migrations для обновления базы данных...»*
    Опять же проблема заключается в моментальный снимок модели, хранящихся в последней миграции не соответствует текущей модели.
3.  Наконец, ожидается, что выполнение **Add-Migration** теперь создаст пустой миграции (так как нет изменений для применения к базе данных). Но так как миграция сравнивает текущую модель к одному из последней миграции (которой отсутствует **Оценка** свойство) он фактически будет формировать другой **AddColumn** вызов для добавления в **Оценка** столбца. Конечно, этот вид миграции произойдет во время **Update-Database** поскольку **Оценка** столбец уже существует.

## <a name="resolving-the-merge-conflict"></a>Разрешение конфликта слияния

Хорошей новостью является то, что это не слишком трудно справиться со слиянием вручную — при этом требуется понимание того, как работает миграция. Таким образом, если пропущены вперед к этому разделу... к сожалению вам нужно вернуться назад и сначала прочитать в оставшейся части статьи!

Существует два варианта, лучше всего создайте пустой перенос с правильного текущей модели как моментальный снимок. Второй вариант — для обновления моментального снимка в последней миграции на правильный моментальный снимок модели. Второй вариант немного сложнее и не может использоваться в каждом сценарии, но это также чище, поскольку он не включает добавление дополнительных миграции.

### <a name="option-1-add-a-blank-merge-migration"></a>Вариант 1: Добавление миграции пустой «слияние»

В этом параметре, мы создаем пустой миграцию только с целью убедиться, что для последней переноса правильную модель моментального снимка, сохраненного в них.

Этот параметр можно использовать независимо от создавшего последней миграции. В примере, мы выполняли разработчика \#2 принципиально слияния, и они возникли для создания последней миграции. Но эти же действия можно использовать, если разработчик \#1 создан последней миграции. Эти действия также применимы, если задействованы несколько миграций — мы только что рассмотрели два для простоты.

Для этого подхода, начиная с момента вы поймете, что у вас есть изменения, которые должны быть синхронизированы из системы управления версиями можно использовать следующий процесс.

1.  Убедитесь, что любые изменения ожидающие модели в базе данных локального кода были записаны для миграции. Этот шаг гарантирует, что не пропустите любой законные возможности внесения изменений, когда придет время для создания пустого миграции.
2.  Синхронизация с системой управления версиями.
3.  Запустите **Update-Database** применить все новые миграции, которые возвращены в других разработчиков.
    **_Примечание:_**  *Если вы не получаете предупреждения на наличие с помощью команды Update-Database, а затем было ни одной новой миграции от других разработчиков, и нет необходимости для выполнения дальнейшей слияние.*
4.  Запустите **Add-Migration &lt;выбрать\_\_имя&gt; — IgnoreChanges** (например, **Add-Migration слияния — IgnoreChanges**). Это приводит к возникновению ошибки миграции с все метаданные (включая моментальный снимок текущей модели), но игнорирует любые изменения, он определяет при сравнении текущей модели к снимку в последней миграции (то есть вы получаете пустой **вверх** и **Вниз** метод).
5.  Продолжить разработку, или отправьте в систему управления версиями (после запуска модульных тестов конечно).

Здесь находится в состоянии разработчика \#2 локальный кода после использования этого подхода.

![Слияние миграции](~/ef6/media/mergemigration.png)

### <a name="option-2-update-the-model-snapshot-in-the-last-migration"></a>Вариант 2: Обновление моментального снимка модели в последней миграции

Этот параметр очень похоже на вариант 1, но удаляет лишние пустые миграции — поскольку посмотрим правде в глаза, желающий файлы дополнительного кода в свое решение.

**Этот подход возможно только в том случае, если существует только в базе данных локального кода последней миграции и еще не был отправлен в систему управления версиями (например, если последняя миграция была создана пользователем, выполняющим слияния)**. Изменение метаданных миграций, которые другие разработчики уже применяется к их разработке базы данных — или даже хуже, применяется к производственной базы данных — может привести непредвиденные побочные эффекты. Во время процесса мы собираемся откат последней миграции в локальной базе данных и повторно применить с помощью обновленных метаданных.

Во время последней миграции необходимо просто быть в локальной базе нет никаких ограничений на количество или порядок операций миграции, продолжить его кода. Может существовать несколько миграций из нескольких различных разработчиков и те же действия применяются – мы только что рассмотрели два для простоты.

Для этого подхода, начиная с момента вы поймете, что у вас есть изменения, которые должны быть синхронизированы из системы управления версиями можно использовать следующий процесс.

1.  Убедитесь, что любые изменения ожидающие модели в базе данных локального кода были записаны для миграции. Этот шаг гарантирует, что не пропустите любой законные возможности внесения изменений, когда придет время для создания пустого миграции.
2.  Синхронизация с системой управления версиями.
3.  Запустите **Update-Database** применить все новые миграции, которые возвращены в других разработчиков.
    **_Примечание:_**  *Если вы не получаете предупреждения на наличие с помощью команды Update-Database, а затем было ни одной новой миграции от других разработчиков, и нет необходимости для выполнения дальнейшей слияние.*
4.  Запустите **обновления базы данных — TargetMigration &lt;второй\_последнего\_миграции&gt;**  (в примере, мы выполняли это было бы **обновления базы данных — TargetMigration AddRating**). Этой роли базы данных обратно в состояние второй последнего миграции — фактически «без применения» последней миграции из базы данных.
    **_Примечание:_**  *этот шаг необходим, чтобы сделать безопасно изменить метаданные миграции, так как метаданные также хранятся в \_ \_MigrationsHistoryTable базы данных. Именно поэтому этот параметр следует использовать только в случае, если последняя миграция только в локальной базе. Если других баз данных было последней миграцией, применяемой также пришлось бы их откат и повторное применение последней миграции для обновления метаданных.* 
5.  Запустите **Add-Migration &lt;полный\_имя\_включая\_timestamp\_из\_последнего\_миграции** &gt; (в примере мы выполняли это было бы что-нибудь вроде **201311062215252 Add-Migration\_AddReaders**).
    **_Примечание:_**  *необходимо включить метку времени, чтобы миграция знал, нужно изменить существующие миграции, а не формирование шаблонов новый.*
    Будут обновлены метаданные для последней миграции в соответствии с текущей моделью. Вы получите следующее предупреждение, когда команда будет выполнена, но это именно то, что нужно. "*Только код конструктора для миграции" 201311062215252\_AddReaders была повторно шаблонный. Чтобы повторно сформировать шаблон миграции, используйте параметр - Force.»*
6.  Запустите **Update-Database** повторно применить последнюю миграцию с обновленными метаданными.
7.  Продолжить разработку, или отправьте в систему управления версиями (после запуска модульных тестов конечно).

Здесь находится в состоянии разработчика \#2 локальный кода после использования этого подхода.

![Обновлены метаданные](~/ef6/media/updatedmetadata.png)

## <a name="summary"></a>Сводка

Существуют некоторые проблемы при использовании Code First Migrations в среде группы. Тем не менее базовое представление о принципах работы миграций и некоторые простые подходы для разрешения конфликтов слияния позволяют легко преодолеть эти трудности.

Фундаментальные проблема заключается в неверные метаданные, сохраненные в последней миграции. В результате Code First неправильно обнаружить, что текущая модель и схемы базы данных не совпадают и сформировать шаблон неверный код в следующей миграции. Такой ситуации можно устранить путем создания пустой миграцию с подходящей модели или обновления метаданных в последней миграции.
